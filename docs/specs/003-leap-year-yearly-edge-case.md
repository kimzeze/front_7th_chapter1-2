# 작업 003: 윤년 2월 29일 매년 반복 엣지 케이스 처리

## 1. 개요

### 목적

매년 반복 일정에서 2월 29일(윤년에만 존재)을 선택했을 때, 평년(non-leap year)을 건너뛰고 윤년에만 일정을 생성하도록 한다.

### 사용자 시나리오

1. 사용자가 2024년 2월 29일에 "매년" 반복 일정을 생성
2. 2025년은 평년이므로 → **2025년 건너뜀**
3. 2026년은 평년이므로 → **2026년 건너뜀**
4. 2027년은 평년이므로 → **2027년 건너뜀**
5. 2028년은 윤년이므로 → **2028년 2월 29일 생성**

### 배경

작업 002에서 구현한 `getNextOccurrence()` 함수의 yearly 케이스는 단순히 `setFullYear(year + 1)`을 사용하므로, 2월 29일에 +1년을 하면 평년의 2월 28일이 됩니다. 이는 의도와 다릅니다.

**현재 동작 (잘못됨)**:
```
2024-02-29 → 2025-02-28 → 2026-02-28 → 2027-02-28 ...
```

**원하는 동작**:
```
2024-02-29 → (2025~2027 건너뜀) → 2028-02-29
```

---

## 2. 요구사항

### 2.1 기능 요구사항

- [ ] 매년 반복에서 시작일이 2월 29일인 경우, 평년은 건너뛴다
- [ ] 윤년에만 일정을 생성한다
- [ ] 2월 29일이 아닌 날짜는 기존 동작 유지 (모든 해에 생성)
- [ ] 다른 반복 유형(daily, weekly, monthly)에는 영향을 주지 않는다

### 2.2 비기능 요구사항

- **기존 테스트 유지**: 작업 001, 002의 26개 테스트는 여전히 통과해야 함
- **성능**: 윤년 검증 로직으로 인한 성능 저하 최소화

---

## 3. 영향 범위

### 3.1 수정이 필요한 파일

- `src/utils/recurringEventUtils.ts`
  - `getNextOccurrence()` 함수 수정 (yearly 케이스)
  - 또는 새로운 `getNextYearlyOccurrence()` 헬퍼 함수 추가

### 3.2 새로 생성할 파일

- 없음

---

## 4. 구현 방법

### 방법 1: getNextOccurrence()에서 윤년 검증 (권장)

```typescript
case 'yearly': {
  const originalMonth = currentDate.getMonth();
  const originalDay = currentDate.getDate();

  // 2월 29일이 아닌 경우: 기존 동작
  if (!(originalMonth === 1 && originalDay === 29)) {
    const next = new Date(currentDate);
    next.setFullYear(next.getFullYear() + 1);
    return next;
  }

  // 2월 29일인 경우: 다음 윤년 찾기
  let year = currentDate.getFullYear() + 1;
  while (year <= MAX_YEAR) {
    if (isLeapYear(year)) {
      return new Date(year, 1, 29); // 1 = 2월 (0-indexed)
    }
    year++;
  }

  return null; // MAX_YEAR 초과
}
```

### 방법 2: 별도 헬퍼 함수 추출

```typescript
case 'yearly':
  return getNextYearlyOccurrence(currentDate);

function getNextYearlyOccurrence(currentDate: Date): Date | null {
  const month = currentDate.getMonth();
  const day = currentDate.getDate();

  // 2월 29일이 아닌 경우
  if (!(month === 1 && day === 29)) {
    const next = new Date(currentDate);
    next.setFullYear(next.getFullYear() + 1);
    return next;
  }

  // 2월 29일인 경우: 다음 윤년 찾기
  return findNextLeapYearDate(currentDate);
}
```

**선택**: **방법 2**를 사용 (작업 002와 일관성 유지)
- 이유: 책임 분리, 테스트 용이성, 가독성 향상

---

## 5. 알고리즘

### 윤년 판별 규칙

```typescript
function isLeapYear(year: number): boolean {
  // 1. 4로 나누어떨어지지 않으면 평년
  if (year % 4 !== 0) return false;

  // 2. 100으로 나누어떨어지지만 400으로 나누어떨어지지 않으면 평년
  if (year % 100 === 0 && year % 400 !== 0) return false;

  // 3. 그 외는 윤년
  return true;
}
```

**예시**:
- 2024: 4로 나누어떨어짐 → **윤년** ✅
- 2025: 4로 나누어떨어지지 않음 → 평년 ❌
- 2100: 100으로 나누어떨어지지만 400으로는 안 됨 → 평년 ❌
- 2000: 400으로 나누어떨어짐 → **윤년** ✅

### 다음 윤년 찾기 로직

```
1. currentDate = 2024-02-29
2. year = 2024 + 1 = 2025
3. while (year <= 2025):  // MAX_DATE = 2025-12-31
     - isLeapYear(2025)? false → 계속
     - year = 2026
     - year > 2025 → 종료
4. return null (MAX_DATE 초과)
```

---

## 6. 엣지 케이스

### 6.1 윤년 2월 29일 매년 반복 (MAX_DATE 제한)

- **입력**: 2024-02-29, yearly, endDate: 2030-12-31
- **MAX_DATE**: 2025-12-31
- **출력**: 1개 (2024-02-29만)
- **건너뜀**: 2025, 2026, 2027 (평년), 2028 (윤년이지만 MAX_DATE 초과)

### 6.2 평년 2월 28일 매년 반복

- **입력**: 2024-02-28, yearly, endDate: 2030-12-31
- **MAX_DATE**: 2025-12-31
- **출력**: 2개 (2024-02-28, 2025-02-28)
- **건너뜀**: 없음 (28일은 모든 해에 존재)

### 6.3 일반 날짜 매년 반복

- **입력**: 2024-03-15, yearly, endDate: 2027-12-31
- **MAX_DATE**: 2025-12-31
- **출력**: 2개 (2024-03-15, 2025-03-15)
- **건너뜀**: 없음 (일반 날짜는 윤년 검증 불필요)

### 6.4 윤년 2월 29일 매년 반복 (충분한 범위)

- **입력**: 2024-02-29, yearly, endDate: 2040-12-31
- **MAX_DATE**: 2040-12-31로 확장된 경우
- **출력**: 5개 (2024, 2028, 2032, 2036, 2040)
- **건너뜀**: 2025~2027, 2029~2031, 2033~2035, 2037~2039

---

## 7. 테스트 시나리오 (간략)

### 추가할 테스트

- [ ] 윤년 2월 29일 매년 반복: 평년 건너뛰고 윤년에만 생성
- [ ] 평년 2월 28일 매년 반복: 모든 해에 생성
- [ ] 일반 날짜 매년 반복: 기존 동작 유지
- [ ] 윤년 2월 29일 + MAX_DATE 제한: 1개만 생성

### 기존 테스트 유지

- [ ] 작업 001, 002의 26개 테스트는 여전히 통과해야 함

---

## 8. 예시

### 예시 1: 윤년 2월 29일 매년 반복 (MAX_DATE 제한)

**입력**:
```typescript
const baseEvent: EventForm = {
  title: '윤년 기념일',
  date: '2024-02-29',
  repeat: {
    type: 'yearly',
    interval: 1,
    endDate: '2030-12-31'
  },
  // ...
};
```

**출력**:
```typescript
[
  { date: '2024-02-29', ... }, // 윤년
  // 2025, 2026, 2027 건너뜀 (평년)
  // 2028은 윤년이지만 MAX_DATE(2025-12-31) 초과로 생성 안 됨
]
// 총 1개
```

### 예시 2: 평년 2월 28일 매년 반복

**입력**:
```typescript
const baseEvent: EventForm = {
  title: '생일',
  date: '2024-02-28',
  repeat: {
    type: 'yearly',
    interval: 1,
    endDate: '2026-12-31'
  },
  // ...
};
```

**출력**: 3개 (2024-02-28, 2025-02-28, 2026-02-28)

---

## 9. 구현 계획

### Phase 1: 명세 작성

1. ✅ 이 문서 작성

### Phase 2: 테스트 설계

2. 윤년 2월 29일 매년 반복 테스트 설계
3. 평년 2월 28일 매년 반복 테스트 설계
4. 일반 날짜 매년 반복 테스트 설계

### Phase 3: RED - 테스트 작성

5. 실패하는 테스트 작성
6. RED 커밋

### Phase 4: GREEN - 기능 구현

7. `isLeapYear()` 헬퍼 함수 구현
8. `getNextYearlyOccurrence()` 함수 구현 (또는 기존 yearly 케이스 수정)
9. 테스트 통과 확인
10. GREEN 커밋

### Phase 5: REFACTOR

11. 코드 정리 및 최적화
12. 주석 추가
13. REFACTOR 커밋

---

## 10. 다음 작업과의 관계

- **작업 001**: 완료 (기본 반복 생성 로직)
- **작업 002**: 완료 (31일 매월 반복)
- **작업 003**: 현재 (윤년 2월 29일 매년 반복)
- **작업 004**: 종료일 로직은 이미 작업 001에 포함됨
- **작업 005**: UI 활성화 (다음)

작업 003은 **yearly** 반복에만 영향을 줍니다.

---

## 11. 주의사항

### JavaScript Date 동작

```javascript
const date = new Date('2024-02-29');
date.setFullYear(2025); // 평년
console.log(date); // 2025-02-28 (자동 조정!)
```

JavaScript는 유효하지 않은 날짜를 자동으로 조정합니다. 2월 29일 + 1년 = 2025-02-28이 되므로, 날짜가 변경되었는지 검증해야 합니다.

### MAX_DATE 제한

현재 MAX_DATE는 2025-12-31이므로, 2024-02-29 이후 다음 윤년인 2028-02-29는 생성되지 않습니다. 테스트에서 이를 고려해야 합니다.

### 성능

윤년 검증은 간단한 연산이므로 성능 영향은 미미합니다. 하지만 while 루프에서 무한 루프를 방지하기 위해 MAX_DATE 검증이 필수입니다.

---

## 12. 참고

### 윤년 규칙

- 4년마다 윤년 (예: 2024)
- 단, 100년마다 평년 (예: 2100)
- 단, 400년마다 윤년 (예: 2000)

### 다음 윤년 목록 (2024~2100)

2024, 2028, 2032, 2036, 2040, 2044, 2048, 2052, 2056, 2060, 2064, 2068, 2072, 2076, 2080, 2084, 2088, 2092, 2096

**주의**: 2100년은 평년 (100으로 나누어떨어지지만 400으로는 안 됨)
